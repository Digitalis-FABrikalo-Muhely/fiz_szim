<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F√©nyt√∂r√©s Szimul√°ci√≥ - DigiFAB</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            margin: 0;
            touch-action: none;
        }

        .header {
            background-color: #2563eb;
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 50;
        }

        .header h1 { margin: 0; font-size: 1.25rem; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        .header h1 span { font-weight: 900; opacity: 0.8; font-size: 0.9rem; }
        
        .badge { background-color: #1d4ed8; padding: 6px 16px; border-radius: 9999px; font-size: 0.8rem; font-weight: 700; }

        .footer {
            background-color: #0f172a;
            padding: 24px;
            color: white;
            font-size: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0.95;
            font-family: monospace;
            z-index: 50;
        }

        .layout-wrapper {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 60px - 60px); 
            flex: 1;
        }

        @media (min-width: 1024px) {
            .layout-wrapper { flex-direction: row; }
            .sidebar { width: 380px; min-width: 380px; border-left: 1px solid #e2e8f0; }
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background-color: #f1f5f9;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
        }

        .sidebar {
            background-color: white;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: -4px 0 15px rgba(0,0,0,0.02);
        }

        .measurement-card {
            background-color: #f8fafc;
            border-radius: 16px;
            padding: 16px;
            border: 1px solid #e2e8f0;
            border-left: 4px solid #2563eb;
        }

        .control-label {
            display: block;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #64748b;
            margin-bottom: 10px;
        }

        .btn-modern {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            font-weight: 800;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .btn-modern:active { transform: scale(0.98); }

        .explanation-box {
            background-color: #eff6ff;
            border-radius: 16px;
            padding: 20px;
            border: 1px solid #dbeafe;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #1e3a8a;
        }

        .math-text { font-family: "Times New Roman", Times, serif; font-style: italic; text-transform: none !important; }

        .hidden-info { display: none; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div class="header">
        <div class="header-left">
            <h1><span>FIZIKA</span> üê° F√©nyt√∂r√©s</h1>
        </div>
        <div class="header-center font-black text-xl tracking-tighter opacity-80 hidden md:block">DigiFAB</div>
        <div class="header-right">
            <span class="badge">8. oszt√°ly</span>
        </div>
    </div>

    <div class="layout-wrapper">
        <div class="canvas-area">
            <canvas id="opticsCanvas"></canvas>
            
            <div id="miss-feedback" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none opacity-0 transition-opacity duration-300 z-40">
                <span class="bg-red-600/90 backdrop-blur-sm text-white px-8 py-4 rounded-2xl font-black text-2xl shadow-2xl uppercase tracking-widest border-2 border-white/20">Elt√©vesztetted!</span>
            </div>

            <div id="data-displays" class="absolute bottom-6 left-6 grid grid-cols-2 gap-3 opacity-0 transition-opacity duration-300 pointer-events-none">
                <div class="bg-white/90 backdrop-blur px-4 py-2 rounded-xl border border-orange-200 shadow-sm">
                    <span class="text-[9px] font-black text-orange-800 uppercase block">C√©lz√°si sz√∂g</span>
                    <span id="angle-inc-display" class="text-xl font-black text-orange-600 font-mono">0¬∞</span>
                </div>
                <div class="bg-white/90 backdrop-blur px-4 py-2 rounded-xl border border-green-200 shadow-sm">
                    <span class="text-[9px] font-black text-green-800 uppercase block">T√∂r√©si sz√∂g</span>
                    <span id="angle-ref-display" class="text-xl font-black text-green-600 font-mono">0¬∞</span>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <span class="control-label">K√∂rnyezet</span>
                <div class="measurement-card">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs font-bold text-slate-500">Leveg≈ë (ritk√°bb)</span>
                        <span class="text-blue-600 font-black font-mono text-sm"><span class="math-text">n‚ÇÅ</span>=1.00</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-bold text-slate-500">V√≠z (s≈±r≈±bb)</span>
                        <span class="text-cyan-600 font-black font-mono text-sm"><span class="math-text">n‚ÇÇ</span>=1.33</span>
                    </div>
                </div>
            </div>

            <div class="space-y-3">
                <button id="toggle-sun" class="btn-modern bg-yellow-500 hover:bg-yellow-600 text-white shadow-yellow-200">
                    <i data-lucide="sun" class="w-4 h-4"></i> Nappali vil√°g√≠t√°s
                </button>
                
                <button id="toggle-real-fish" class="btn-modern bg-emerald-600 hover:bg-emerald-700 text-white shadow-emerald-200 opacity-50 cursor-not-allowed" disabled>
                    <i data-lucide="eye" class="w-4 h-4"></i> A hal val√≥di helyzete
                </button>

                <button id="toggle-static-arrow" class="btn-modern bg-rose-600 hover:bg-rose-700 text-white shadow-rose-200 opacity-50 cursor-not-allowed" disabled>
                    <i data-lucide="target" class="w-4 h-4"></i> √çj megjelen√≠t√©se
                </button>
                
                <button id="toggle-explanation" class="btn-modern bg-slate-800 hover:bg-slate-900 text-white shadow-slate-200">
                    <i data-lucide="info" class="w-4 h-4"></i> Jelens√©g magyar√°zata
                </button>
            </div>

            <div id="explanation-content" class="hidden-info explanation-box space-y-3 animate-in fade-in duration-300">
                <h3 class="font-black text-[10px] uppercase tracking-widest text-blue-800 border-b border-blue-200 pb-2 flex items-center gap-2">
                    <i data-lucide="book-open" class="w-3.5 h-3.5"></i> Mi√©rt l√°tunk m√°shol?
                </h3>
                <p>A halr√≥l visszaver≈ëd≈ë f√©nysugarak a v√≠zfelsz√≠nhez √©rve a leveg≈ëbe l√©pnek. Mivel a v√≠z optikailag s≈±r≈±bb k√∂zeg, a f√©ny a <b>mer≈ëlegest≈ël t√°volodva</b> megt√∂rik.</p>
                <p>Az emberi agy √∫gy √©rz√©keli, mintha a f√©ny egyenes vonalban √©rkezett volna. Ez√©rt a szem√ºnkbe √©rkez≈ë megt√∂rt sugarat <b>egyenesen vet√≠ti vissza</b> a v√≠z al√°.</p>
                <p class="bg-blue-100 p-3 rounded-lg border-l-4 border-blue-500 font-bold italic text-blue-900">Ha el akarod tal√°lni a halat, a l√°tott k√©p al√° kell c√©loznod!</p>
            </div>
        </div>
    </div>

    <div class="footer">
        <span>Digit√°lis FABrik√°l√≥ M≈±hely</span>
        <span class="text-blue-500 font-black">.:henz:.</span>
        <span>Henzel Gy√∂rgy</span>
    </div>

    <script>
        lucide.createIcons();

        const canvas = document.getElementById('opticsCanvas');
        const ctx = canvas.getContext('2d');
        const angleIncDisplay = document.getElementById('angle-inc-display');
        const angleRefDisplay = document.getElementById('angle-ref-display');
        const toggleBtn = document.getElementById('toggle-explanation');
        const explanationContent = document.getElementById('explanation-content');
        const toggleRealFishBtn = document.getElementById('toggle-real-fish');
        const toggleStaticArrowBtn = document.getElementById('toggle-static-arrow');
        const toggleSunBtn = document.getElementById('toggle-sun');
        const dataDisplays = document.getElementById('data-displays');
        const missFeedback = document.getElementById('miss-feedback');

        let showRealFish = false, showRayPath = false, showStaticArrow = false, isSunOn = false;
        let width, height;
        const defaultAngle = 0.5;
        let angleInc = defaultAngle;

        let lockedFishX = 0, lockedFishY = 0;
        let lockedApparentX = 0, lockedApparentY = 0;
        let lockedHitX = 0; 
        
        let lastMouseX = 0, lastMouseY = 0;
        let projectiles = [];
        let hitArrows = []; 
        let feedbackTimer = null;

        const n1 = 1.00; 
        const n2 = 1.33; 
        const fishDepth = 180;
        const boatXPercent = 0.8; 
        let eyeX, eyeY, bowX, bowY;
        const sunX = 70, sunY = 70;

        function findRefractionPoint(sourceX, sourceY, targetX, targetY, surfaceY, n1, n2) {
            let left = Math.min(sourceX, targetX);
            let right = Math.max(sourceX, targetX);
            for (let i = 0; i < 20; i++) {
                let mid = (left + right) / 2;
                let sin1 = (mid - sourceX) / Math.sqrt(Math.pow(mid - sourceX, 2) + Math.pow(surfaceY - sourceY, 2));
                let sin2 = (targetX - mid) / Math.sqrt(Math.pow(targetX - mid, 2) + Math.pow(targetY - surfaceY, 2));
                if (n1 * sin1 < n2 * sin2) left = mid;
                else right = mid;
            }
            return (left + right) / 2;
        }

        function triggerMissFeedback() {
            if (feedbackTimer) clearTimeout(feedbackTimer);
            missFeedback.classList.replace('opacity-0', 'opacity-100');
            feedbackTimer = setTimeout(() => {
                missFeedback.classList.replace('opacity-100', 'opacity-0');
            }, 1200);
        }

        toggleSunBtn.addEventListener('click', () => {
            isSunOn = !isSunOn;
            toggleSunBtn.innerHTML = isSunOn ? '<i data-lucide="moon" class="w-4 h-4"></i> √âjszakai m√≥d' : '<i data-lucide="sun" class="w-4 h-4"></i> Nappali vil√°g√≠t√°s';
            toggleSunBtn.classList.toggle('bg-yellow-500', !isSunOn);
            toggleSunBtn.classList.toggle('bg-slate-700', isSunOn);
            lucide.createIcons();
            
            [toggleRealFishBtn, toggleStaticArrowBtn].forEach(btn => {
                btn.disabled = !isSunOn;
                btn.classList.toggle('opacity-50', !isSunOn);
                btn.classList.toggle('cursor-not-allowed', !isSunOn);
            });

            if (!isSunOn) resetSimulation();
        });

        function resetSimulation() {
            showRealFish = false;
            showRayPath = false;
            showStaticArrow = false;
            angleInc = defaultAngle;
            lockedFishX = lockedFishY = lockedApparentX = lockedApparentY = lockedHitX = 0;
            projectiles = [];
            hitArrows = [];
            toggleRealFishBtn.innerHTML = '<i data-lucide="eye" class="w-4 h-4"></i> A hal val√≥di helyzete';
            toggleStaticArrowBtn.innerHTML = '<i data-lucide="target" class="w-4 h-4"></i> √çj megjelen√≠t√©se';
            lucide.createIcons();
            dataDisplays.classList.replace('opacity-100', 'opacity-0');
            missFeedback.classList.replace('opacity-100', 'opacity-0');
        }

        toggleRealFishBtn.addEventListener('click', () => {
            if (!isSunOn) return;
            showRealFish = !showRealFish;
            showRayPath = showRealFish; 
            toggleRealFishBtn.innerHTML = showRealFish ? '<i data-lucide="eye-off" class="w-4 h-4"></i> Val√≥di helyzet elrejt√©se' : '<i data-lucide="eye" class="w-4 h-4"></i> A hal val√≥di helyzete';
            lucide.createIcons();
            if (showRealFish) dataDisplays.classList.replace('opacity-0', 'opacity-100');
            else dataDisplays.classList.replace('opacity-100', 'opacity-0');
        });

        toggleStaticArrowBtn.addEventListener('click', () => {
            if (!isSunOn) return;
            if (!showStaticArrow) {
                const centerY = height / 2;
                lockedHitX = eyeX - Math.tan(angleInc) * (centerY - eyeY);
                const angleRef = Math.asin((n1 / n2) * Math.sin(angleInc));
                lockedFishX = lockedHitX - Math.sin(angleRef) * (fishDepth / Math.cos(angleRef));
                lockedFishY = centerY + fishDepth;
                const apparentDepth = fishDepth * (n1 / n2);
                lockedApparentX = lockedHitX - Math.sin(angleInc) * (apparentDepth / Math.cos(angleInc));
                lockedApparentY = centerY + apparentDepth;
            } else {
                hitArrows = [];
            }
            showStaticArrow = !showStaticArrow;
            toggleStaticArrowBtn.innerHTML = showStaticArrow ? '<i data-lucide="x-circle" class="w-4 h-4"></i> √çj elrejt√©se' : '<i data-lucide="target" class="w-4 h-4"></i> √çj megjelen√≠t√©se';
            lucide.createIcons();
        });

        toggleBtn.addEventListener('click', () => {
            explanationContent.classList.toggle('hidden-info');
            toggleBtn.innerHTML = explanationContent.classList.contains('hidden-info') ? '<i data-lucide="info" class="w-4 h-4"></i> Jelens√©g magyar√°zata' : '<i data-lucide="x" class="w-4 h-4"></i> Magyar√°zat elrejt√©se';
            lucide.createIcons();
        });

        function resize() {
            width = canvas.parentElement.clientWidth;
            height = canvas.parentElement.clientHeight;
            canvas.width = width;
            canvas.height = height;
            eyeX = width * boatXPercent;
            eyeY = height / 2 - 97; 
            bowX = eyeX - 45;
            bowY = eyeY + 25;
        }

        window.addEventListener('resize', resize);
        
        function handleInput(e) {
            if (!isSunOn) return;
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            if (clientX === undefined) return;
            lastMouseX = clientX - rect.left;
            lastMouseY = clientY - rect.top;
            if (!showStaticArrow) {
                const dx = eyeX - lastMouseX;
                const dy = lastMouseY - eyeY;
                if (dy > 10) angleInc = Math.max(0.01, Math.min(1.5, Math.atan2(dx, dy)));
            }
        }

        function shootProjectile() {
            if (!isSunOn || !showStaticArrow) return;
            const dx = lastMouseX - bowX;
            const dy = lastMouseY - bowY;
            const angle = Math.atan2(dy, dx);
            const speed = 14;
            projectiles.push({ x: bowX, y: bowY, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, angle: angle });
        }

        canvas.addEventListener('mousedown', (e) => {
            canvas.isDragging = true;
            handleInput(e);
            if (showStaticArrow) shootProjectile();
        });
        window.addEventListener('mousemove', (e) => { if (canvas.isDragging || showStaticArrow) handleInput(e); });
        window.addEventListener('mouseup', () => canvas.isDragging = false);
        canvas.addEventListener('touchstart', (e) => { 
            canvas.isDragging = true; 
            handleInput(e);
            if (showStaticArrow) shootProjectile();
            e.preventDefault(); 
        }, {passive: false});
        window.addEventListener('touchmove', (e) => { handleInput(e); e.preventDefault(); }, {passive: false});
        window.addEventListener('touchend', () => canvas.isDragging = false);

        function drawHuman(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(-1, 1); 
            ctx.fillStyle = isSunOn ? '#1e40af' : '#1e293b'; 
            ctx.beginPath(); 
            if (ctx.roundRect) ctx.roundRect(-15, -65, 30, 42, 8);
            else ctx.rect(-15, -65, 30, 42);
            ctx.fill();
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 14; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-7, -28); ctx.lineTo(-18, -2); ctx.moveTo(7, -28); ctx.lineTo(18, -2); ctx.stroke();
            ctx.strokeStyle = isSunOn ? '#fca5a5' : '#8a5c5c'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(-10, -55); ctx.lineTo(-42, -45); ctx.moveTo(10, -55); ctx.lineTo(36, -48); ctx.stroke();
            ctx.fillStyle = isSunOn ? '#fca5a5' : '#8a5c5c';
            ctx.beginPath(); ctx.arc(0, -82, 16, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#334155'; ctx.beginPath(); ctx.ellipse(0, -94, 24, 8, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillRect(-12, -104, 24, 12);
            ctx.restore();
        }

        function drawBoat(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(-1, 1); 
            ctx.font = "145px Arial"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            if (!isSunOn) ctx.globalAlpha = 0.4;
            ctx.fillText("üõ∂", 0, -18); 
            ctx.restore();
        }

        function drawBow(x, y) {
            ctx.save();
            ctx.translate(x, y);
            const dx = lastMouseX - bowX;
            const dy = lastMouseY - bowY;
            const targetAngle = Math.atan2(dy, dx);
            ctx.rotate(targetAngle + Math.PI / 4);
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.font = "60px Arial"; 
            ctx.fillText("üèπ", 0, 0);
            ctx.restore();
        }

        function drawProjectile(proj) {
            ctx.save();
            ctx.translate(proj.x, proj.y);
            ctx.rotate(proj.angle);
            ctx.beginPath(); ctx.strokeStyle = '#57534e'; ctx.lineWidth = 3; ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.stroke();
            ctx.beginPath(); ctx.fillStyle = '#292524'; ctx.moveTo(15, 0); ctx.lineTo(5, -4); ctx.lineTo(5, 4); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 2; ctx.moveTo(-15, 0); ctx.lineTo(-20, -5); ctx.moveTo(-15, 0); ctx.lineTo(-20, 5); ctx.stroke();
            ctx.restore();
        }

        function animatePath(points, color, isDashed = false, speed = 250, reverse = false) {
            const time = Date.now() / 1000;
            let totalLength = 0, segments = [];
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i+1].x - points[i].x, dy = points[i+1].y - points[i].y;
                const len = Math.sqrt(dx*dx + dy*dy);
                segments.push({ p1: points[i], p2: points[i+1], len: len });
                totalLength += len;
            }
            ctx.save();
            if (isDashed) ctx.setLineDash([8, 8]);
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = isDashed ? 2 : 1.5; ctx.globalAlpha = isDashed ? 0.6 : 0.4;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke(); ctx.restore();

            const count = 3;
            for (let j = 0; j < count; j++) {
                const offset = (totalLength / count) * j;
                let dist;
                if (!reverse) dist = (time * speed + offset) % totalLength;
                else dist = (totalLength - (time * speed + offset) % totalLength) % totalLength;

                let traversed = 0;
                for (let seg of segments) {
                    if (dist <= traversed + seg.len) {
                        const ratio = (dist - traversed) / seg.len;
                        const px = seg.p1.x + (seg.p2.x - seg.p1.x) * ratio;
                        const py = seg.p1.y + (seg.p2.y - seg.p1.y) * ratio;
                        let ang = Math.atan2(seg.p2.y - seg.p1.y, seg.p2.x - seg.p1.x);
                        if (reverse) ang += Math.PI;
                        drawArrowHead(px, py, ang, color);
                        break;
                    }
                    traversed += seg.len;
                }
            }
        }

        function drawArrowHead(x, y, angle, color) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
            ctx.beginPath(); ctx.moveTo(-10, -6); ctx.lineTo(6, 0); ctx.lineTo(-10, 6);
            ctx.fillStyle = color; ctx.fill();
            ctx.restore();
        }

        function drawNormal(x, surfaceY) {
            ctx.save();
            ctx.setLineDash([10, 5]); ctx.strokeStyle = '#334155'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(x, surfaceY - 100); ctx.lineTo(x, surfaceY + 100); ctx.stroke();
            ctx.restore();
        }

        function updateProjectiles() {
            if (!showStaticArrow) return;
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx; p.y += p.vy;
                const dist = Math.sqrt((p.x - lockedFishX)**2 + (p.y - lockedFishY)**2);
                
                // TAL√ÅLAT
                if (dist < 25) { 
                    if (!showRealFish) {
                        showRealFish = true;
                        toggleRealFishBtn.innerHTML = '<i data-lucide="eye-off" class="w-4 h-4"></i> Val√≥di helyzet elrejt√©se';
                        lucide.createIcons();
                    }
                    hitArrows.push({...p});
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // MELL√âL√ñV√âS
                if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
                    projectiles.splice(i, 1);
                    triggerMissFeedback();
                }
            }
        }

        function draw() {
            const centerY = height / 2;
            ctx.clearRect(0, 0, width, height);

            const hitX = eyeX - Math.tan(angleInc) * (centerY - eyeY);
            const angleRef = Math.asin((n1 / n2) * Math.sin(angleInc));

            let skyGrad = ctx.createLinearGradient(0, 0, 0, centerY);
            if (isSunOn) { skyGrad.addColorStop(0, '#bae6fd'); skyGrad.addColorStop(1, '#f8fafc'); }
            else { skyGrad.addColorStop(0, '#0f172a'); skyGrad.addColorStop(1, '#1e293b'); }
            ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, width, centerY);

            if (isSunOn) {
                ctx.save(); ctx.translate(sunX, sunY); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth = 3;
                for (let i = 0; i < 12; i++) { const a = i * Math.PI / 6; ctx.beginPath(); ctx.moveTo(Math.cos(a)*35, Math.sin(a)*35); ctx.lineTo(Math.cos(a)*50, Math.sin(a)*50); ctx.stroke(); }
                ctx.beginPath(); ctx.fillStyle = '#f59e0b'; ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.fillStyle = '#fbbf24'; ctx.arc(0,0,25,0,Math.PI*2); ctx.fill(); ctx.restore();
            }

            drawBoat(eyeX, centerY);
            let waterGrad = ctx.createLinearGradient(0, centerY, 0, height);
            if (isSunOn) { waterGrad.addColorStop(0, '#7dd3fc'); waterGrad.addColorStop(0.2, '#38bdf8'); waterGrad.addColorStop(1, '#0284c7'); }
            else { waterGrad.addColorStop(0, '#0a192f'); waterGrad.addColorStop(1, '#020617'); }
            ctx.fillStyle = waterGrad; ctx.fillRect(0, centerY, width, height - centerY);

            drawHuman(eyeX, centerY - 15);

            const currentRealX = hitX - Math.sin(angleRef) * (fishDepth / Math.cos(angleRef));
            const currentRealY = centerY + fishDepth;
            const currentAppX = hitX - Math.sin(angleInc) * (fishDepth * (n1 / n2) / Math.cos(angleInc));
            const currentAppY = centerY + fishDepth * (n1 / n2);

            if (isSunOn) {
                const activeFishX = showStaticArrow ? lockedFishX : currentRealX;
                const activeFishY = showStaticArrow ? lockedFishY : currentRealY;
                const activeAppX = showStaticArrow ? lockedApparentX : currentAppX;
                const activeAppY = showStaticArrow ? lockedApparentY : currentAppY;
                const activeHitX = showStaticArrow ? lockedHitX : hitX;

                // L√ÅTSZ√ìLAGOS HAL (NARANCSS√ÅRGA)
                ctx.save(); 
                ctx.translate(activeAppX, activeAppY); 
                ctx.globalAlpha = 0.5; 
                ctx.shadowBlur = 15; ctx.shadowColor = "white";
                ctx.fillStyle = "#ff9900"; 
                ctx.font = "52px Arial"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                ctx.fillText("üê°", 0, 0);
                ctx.restore();

                if (showRealFish) {
                    // VAL√ìDI HAL (NARANCSS√ÅRGA)
                    ctx.save(); 
                    ctx.translate(activeFishX, activeFishY); 
                    ctx.fillStyle = "#ff4500"; 
                    ctx.font = "52px Arial"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                    ctx.fillText("üê°", 0, 0);
                    ctx.restore();

                    hitArrows.forEach(drawProjectile);
                    
                    // L√°t√≥vonal nyilak n√©lk√ºl
                    ctx.save();
                    ctx.setLineDash([8, 8]); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
                    ctx.beginPath(); ctx.moveTo(activeAppX, activeAppY); ctx.lineTo(activeHitX, centerY); ctx.lineTo(eyeX, eyeY);
                    ctx.stroke(); ctx.restore();

                    const hitSunX = findRefractionPoint(sunX, sunY, activeFishX, activeFishY, centerY, n1, n2);
                    animatePath([{x: sunX, y: sunY}, {x: hitSunX, y: centerY}, {x: activeFishX, y: activeFishY}], '#fbbf24', false, 300);
                    drawNormal(hitSunX, centerY); 
                    animatePath([{x: activeFishX, y: activeFishY}, {x: activeHitX, y: centerY}, {x: eyeX, y: eyeY}], '#f59e0b', false, 300);
                    drawNormal(activeHitX, centerY); 
                }

                if (showStaticArrow) {
                    drawBow(eyeX - 45, eyeY + 25);
                    if (!showRealFish) {
                        ctx.save();
                        ctx.setLineDash([8, 8]); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
                        ctx.beginPath(); ctx.moveTo(lockedApparentX, lockedApparentY); ctx.lineTo(lockedHitX, centerY); ctx.lineTo(eyeX, eyeY);
                        ctx.stroke(); ctx.restore();
                    }
                }
                projectiles.forEach(drawProjectile);
            }

            const currentAngleValue = showStaticArrow ? Math.atan2(eyeX-lastMouseX, lastMouseY-eyeY) : angleInc;
            angleIncDisplay.textContent = Math.abs(currentAngleValue * 180 / Math.PI).toFixed(1) + '¬∞';
            angleRefDisplay.textContent = Math.abs(angleRef * 180 / Math.PI).toFixed(1) + '¬∞';
        }

        function animate() { 
            updateProjectiles();
            draw(); 
            requestAnimationFrame(animate); 
        }
        
        resize();
        animate();
    </script>
</body>
<button onclick="location.href='index.html'" style="
    position: fixed; 
    top: 10px; 
    right: 140px; 
    padding: 10px 10px; 
    background: #FFF3eb; 
    color: green; 
    border: none; 
    border-radius: 8px; 
    cursor: pointer; 
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(2,2,2,0.2);
">üè†</button>

</html>
