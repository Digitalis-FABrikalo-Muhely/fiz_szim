<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K√©palkot√°s lencs√©kkel - DigiFAB</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        /* --- FEJL√âC √âS L√ÅBLEC ST√çLUSOK --- */
        .header {
            background-color: #2563eb;
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 50;
        }

        .header h1 { margin: 0; font-size: 1.25rem; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        .header h1 span { font-weight: 900; opacity: 0.8; font-size: 0.9rem; }
        
        .badge { background-color: #1d4ed8; padding: 6px 16px; border-radius: 9999px; font-size: 0.8rem; font-weight: 700; }

        .footer {
            background-color: #0f172a;
            padding: 20px;
            color: white;
            font-size: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0.95;
            font-family: monospace;
            z-index: 50;
        }

        /* --- TABS --- */
        .tab-btn {
            padding: 12px 24px;
            font-weight: 800;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            color: #64748b;
        }
        .tab-btn.active {
            color: #2563eb;
            border-bottom-color: #2563eb;
            background-color: white;
        }

        /* --- LAYOUT --- */
        .layout-wrapper {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 60px - 50px); 
            flex: 1;
        }

        @media (min-width: 1024px) {
            .layout-wrapper { flex-direction: row; }
            .sidebar { width: 340px; min-width: 340px; border-left: 1px solid #e2e8f0; }
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background-color: #f1f5f9;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .sidebar {
            background-color: white;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: -4px 0 15px rgba(0,0,0,0.02);
        }

        /* --- INFO PANEL --- */
        .measurement-card {
            background-color: #f8fafc;
            border-radius: 16px;
            padding: 16px;
            border: 1px solid #e2e8f0;
            border-left: 4px solid #2563eb;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .data-label { color: #64748b; font-weight: 600; }
        .data-value { font-weight: 800; color: #1e293b; font-family: monospace; }
        .math-text { font-family: "Times New Roman", Times, serif; font-style: italic; text-transform: none !important; }

        /* --- UI ELEMEK --- */
        .control-label {
            display: block;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #64748b;
            margin-bottom: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid #f1f5f9;
            background-color: #f8fafc;
            transition: all 0.2s;
            font-size: 0.8rem;
            font-weight: 600;
            color: #475569;
        }

        .checkbox-item:hover { background-color: #f1f5f9; border-color: #e2e8f0; }
        .checkbox-item.disabled { opacity: 0.5; pointer-events: none; }
        
        input[type="checkbox"] { width: 18px; height: 18px; accent-color: #2563eb; }

        .legend-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 4px;
        }

        /* --- EGYEDI CS√öSZKA --- */
        #objectPos {
            position: absolute;
            bottom: 20px;
            height: 24px;
            z-index: 20;
            direction: rtl;
            background: transparent;
            -webkit-appearance: none;
            appearance: none;
        }

        #objectPos::-webkit-slider-runnable-track { background: rgba(37, 99, 235, 0.2); height: 6px; border-radius: 3px; }
        #objectPos::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #2563eb;
            border: 3px solid white;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -9px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .btn-reset {
            width: 100%;
            padding: 14px;
            background-color: #0f172a;
            color: white;
            border-radius: 12px;
            font-weight: 800;
            font-size: 0.75rem;
            text-transform: uppercase;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: opacity 0.2s;
        }
        .btn-reset:hover { opacity: 0.9; }

    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- FEJL√âC -->
    <div class="header">
        <div class="header-left">
            <h1><span>FIZIKA</span> üêå K√©palkot√°s lencs√©kkel</h1>
        </div>
        <div class="header-center font-black text-xl tracking-tighter opacity-80 hidden md:block">DigiFAB</div>
        <div class="header-right">
            <span class="badge">8. oszt√°ly</span>
        </div>
    </div>

    <!-- MODUL V√ÅLASZT√ì -->
    <div class="flex bg-slate-50 border-b border-slate-200">
        <button id="btnConvergent" class="tab-btn active" onclick="setLensType('convergent')">
            K√©palkot√°s gy≈±jt≈ëlencs√©vel
        </button>
        <button id="btnDivergent" class="tab-btn" onclick="setLensType('divergent')">
            K√©palkot√°s sz√≥r√≥lencs√©vel
        </button>
    </div>

    <div class="layout-wrapper">
        <!-- Canvas ter√ºlet -->
        <div class="canvas-area">
            <canvas id="opticsCanvas"></canvas>
            
            <!-- Cs√∫szka a csiga mozgat√°s√°hoz -->
            <input type="range" id="objectPos" min="5" max="60" step="0.5" value="30">

            <!-- Interakci√≥ jelz√©s -->
            <div class="absolute top-6 right-6 pointer-events-none">
                <div class="bg-white/90 backdrop-blur-sm px-4 py-2 rounded-full border border-slate-200 text-[10px] font-bold text-slate-500 flex items-center gap-2 shadow-sm">
                    <i data-lucide="mouse-pointer-2" class="w-3 h-3 text-blue-600"></i> H√öZD A CSIG√ÅT A M√ìDOS√çT√ÅSHOZ
                </div>
            </div>
        </div>

        <!-- Vez√©rl≈ëpanel -->
        <div class="sidebar">
            
            <!-- M√âR√âSI ADATOK -->
            <div class="control-group">
                <span class="control-label">M√©r√©si adatok</span>
                <div class="measurement-card">
                    <div class="data-row">
                        <span class="data-label">F√≥kuszt√°vols√°g (<span class="math-text">f</span>):</span>
                        <span id="f-display" class="data-value">10 cm</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">T√°rgyt√°vols√°g (<span class="math-text">t</span>):</span>
                        <span id="do-display" class="data-value text-blue-600">-- cm</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">K√©pt√°vols√°g (<span class="math-text">k</span>):</span>
                        <span id="di-display" class="data-value text-red-600">-- cm</span>
                    </div>
                    <div class="mt-3 pt-3 border-t border-slate-200">
                        <span class="text-[9px] uppercase font-black block opacity-60 mb-1">K√©p t√≠pusa</span>
                        <span id="image-type" class="text-xs font-bold text-purple-600 leading-tight block">--</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Be√°ll√≠t√°sok</span>
                
                <div class="flex flex-col gap-2">
                    <label class="checkbox-item">
                        <input type="checkbox" id="checkSun">
                        <span><span class="legend-dot bg-yellow-400"></span> Napf√©ny (forr√°s)</span>
                    </label>
                    
                    <hr class="border-slate-100 my-1">

                    <label class="checkbox-item" id="labelParallel">
                        <input type="checkbox" id="rayParallel">
                        <span><span class="legend-dot bg-green-500"></span> P√°rhuzamos sug√°r</span>
                    </label>

                    <label class="checkbox-item" id="labelCenter">
                        <input type="checkbox" id="rayCenter">
                        <span><span class="legend-dot bg-orange-500"></span> K√∂z√©pponti sug√°r</span>
                    </label>

                    <label class="checkbox-item" id="labelFocal">
                        <input type="checkbox" id="rayFocal">
                        <span><span class="legend-dot bg-purple-500"></span> F√≥kuszsug√°r</span>
                    </label>
                    
                    <hr class="border-slate-100 my-1">

                    <label class="checkbox-item" id="labelShowImage">
                        <input type="checkbox" id="checkShowImage" checked>
                        <span><span class="legend-dot bg-slate-400"></span> K√©p megjelen√≠t√©se</span>
                    </label>
                </div>
            </div>

            <div class="mt-auto">
                <button onclick="resetSim()" class="btn-reset">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i> Alaphelyzet
                </button>
            </div>
        </div>
    </div>
    
    <!-- L√ÅBLEC -->
    <div class="footer">
        <span>Digit√°lis FABrik√°l√≥ M≈±hely</span>
        <span class="text-blue-500 font-black">.:henz:.</span>
        <span>Henzel Gy√∂rgy</span>
    </div>

<script>
    lucide.createIcons();

    const canvas = document.getElementById('opticsCanvas');
    const ctx = canvas.getContext('2d');
    
    const slider = document.getElementById('objectPos');
    const doDisplay = document.getElementById('do-display');
    const diDisplay = document.getElementById('di-display');
    const fDisplay = document.getElementById('f-display');
    const imgTypeDisplay = document.getElementById('image-type');
    const checkParallel = document.getElementById('rayParallel');
    const checkCenter = document.getElementById('rayCenter');
    const checkFocal = document.getElementById('rayFocal');
    const checkSun = document.getElementById('checkSun');
    const checkShowImage = document.getElementById('checkShowImage');
    
    const labelParallel = document.getElementById('labelParallel');
    const labelCenter = document.getElementById('labelCenter');
    const labelFocal = document.getElementById('labelFocal');

    const SCALE = 10; 
    let lensMode = 'convergent'; 
    let focalLengthCm = 10;
    let f = focalLengthCm * SCALE; 
    let objectHeight = 60; 
    
    let width, height, centerX, centerY;
    let isDragging = false;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        resetSim(); // Alaphelyzetbe √°ll√≠t√°s ind√≠t√°skor
        requestAnimationFrame(animate);
    }

    function setLensType(type) {
        lensMode = type;
        document.getElementById('btnConvergent').classList.toggle('active', type === 'convergent');
        document.getElementById('btnDivergent').classList.toggle('active', type === 'divergent');
        
        if (type === 'convergent') {
            focalLengthCm = 10;
        } else {
            focalLengthCm = -10;
        }
        f = focalLengthCm * SCALE;
        fDisplay.innerText = Math.abs(focalLengthCm) + " cm";
        
        resetSim();
    }

    function resize() {
        const parent = canvas.parentElement;
        canvas.width = parent.clientWidth;
        canvas.height = parent.clientHeight;
        width = canvas.width;
        height = canvas.height;
        centerX = width / 2;
        centerY = height / 2;

        const minDo = 5;
        const maxDo = 60;
        const sliderWidthPx = (maxDo - minDo) * SCALE; 
        const sliderLeftPx = centerX - (maxDo * SCALE);

        slider.style.width = sliderWidthPx + 'px';
        slider.style.left = sliderLeftPx + 'px';
    }

    function updateControlState() {
        const isSunOn = checkSun.checked;
        checkParallel.disabled = !isSunOn;
        checkCenter.disabled = !isSunOn;
        checkFocal.disabled = !isSunOn;

        if (isSunOn) {
            labelParallel.classList.remove('disabled');
            labelCenter.classList.remove('disabled');
            labelFocal.classList.remove('disabled');
        } else {
            labelParallel.classList.add('disabled');
            labelCenter.classList.add('disabled');
            labelFocal.classList.add('disabled');
        }
    }

    checkSun.addEventListener('change', updateControlState);

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('touchstart', startDrag, {passive: false});
    window.addEventListener('mousemove', drag);
    window.addEventListener('touchmove', drag, {passive: false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        return (centerX - (clientX - rect.left)) / SCALE; 
    }

    function startDrag(evt) {
        const currentDo = parseFloat(slider.value);
        const clickPos = getMousePos(evt);
        if (Math.abs(clickPos - currentDo) < 4) {
            isDragging = true;
            evt.preventDefault();
        }
    }

    function drag(evt) {
        if (!isDragging) return;
        evt.preventDefault();
        let newPos = getMousePos(evt);
        newPos = Math.max(5, Math.min(60, newPos));
        slider.value = newPos;
    }

    function endDrag() { isDragging = false; }

    function resetSim() {
        slider.value = 30;
        checkParallel.checked = false;
        checkCenter.checked = false;
        checkFocal.checked = false;
        checkSun.checked = false; 
        checkShowImage.checked = true; // M√≥dos√≠tva: alap√°llapotban igaz
        updateControlState();
    }

    function animate() {
        draw();
        requestAnimationFrame(animate);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        const doCm = parseFloat(slider.value);
        const d_o = doCm * SCALE; 
        
        let d_i = (f * d_o) / (d_o - f);
        let M = -d_i / d_o;
        let imageHeight = objectHeight * M;

        doDisplay.innerText = doCm.toFixed(1) + " cm";
        
        if (lensMode === 'convergent') {
            if (Math.abs(d_o - f) < 1) {
                diDisplay.innerText = "V√©gtelen";
                imgTypeDisplay.innerText = "Nincs k√©p";
            } else {
                diDisplay.innerText = Math.abs(d_i / SCALE).toFixed(1) + " cm";
                if (d_o < f) {
                    imgTypeDisplay.innerText = "L√°tsz√≥lagos, egyenes √°ll√°s√∫, nagy√≠tott";
                } else if (Math.abs(d_o - 2*f) < 2) {
                    imgTypeDisplay.innerText = "Val√≥di, ford√≠tott, azonos nagys√°g√∫";
                } else if (d_o > 2*f) {
                    imgTypeDisplay.innerText = "Val√≥di, ford√≠tott, kicsiny√≠tett";
                } else {
                    imgTypeDisplay.innerText = "Val√≥di, ford√≠tott, nagy√≠tott";
                }
            }
        } else {
            diDisplay.innerText = Math.abs(d_i / SCALE).toFixed(1) + " cm";
            imgTypeDisplay.innerText = "L√°tsz√≥lagos, egyenes √°ll√°s√∫, kicsiny√≠tett";
        }

        drawOpticalBench();
        drawLens();

        // 1. T√ÅRGY
        drawSnail(centerX - d_o, centerY, objectHeight, 1.0, true);

        // 2. K√âP
        if (checkShowImage.checked) {
            if (lensMode === 'convergent' && Math.abs(d_o - f) < 1) {
                // Nincs k√©p
            } else {
                const alpha = (d_i < 0) ? 0.5 : 0.8; 
                drawSnail(centerX + d_i, centerY, imageHeight, alpha, false);
            }
        }

        // NAP √©s SUGARAK
        if (checkSun.checked) {
            const eyeRatio = 45/60;
            const objTipX = centerX - d_o;
            const objTipY = centerY - (objectHeight * eyeRatio);
            
            drawSunAndAnimatedRayTo(objTipX, objTipY);
            drawAnimatedRays(d_o, d_i, objectHeight, imageHeight);
        }
    }

    function drawSunAndAnimatedRayTo(targetX, targetY) {
        const sunX = 60;
        const sunY = 60;
        ctx.beginPath(); ctx.fillStyle = "#fbbf24"; ctx.arc(sunX, sunY, 20, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI * 2) / 8;
            ctx.beginPath(); ctx.moveTo(sunX + Math.cos(angle)*25, sunY + Math.sin(angle)*25);
            ctx.lineTo(sunX + Math.cos(angle)*35, sunY + Math.sin(angle)*35); ctx.stroke();
        }
        ctx.beginPath(); const grad = ctx.createLinearGradient(sunX, sunY, targetX, targetY);
        grad.addColorStop(0, "rgba(251, 191, 36, 0.4)"); grad.addColorStop(1, "rgba(251, 191, 36, 0)");
        ctx.strokeStyle = grad; ctx.lineWidth = 2; ctx.moveTo(sunX, sunY); ctx.lineTo(targetX, targetY); ctx.stroke();
        const dist = Math.sqrt((targetX-sunX)**2 + (targetY-sunY)**2);
        const t = (Date.now() / 1000 * 150) % dist / dist;
        drawArrowHead(sunX + (targetX - sunX) * t, sunY + (targetY - sunY) * t, Math.atan2(targetY - sunY, targetX - sunX), "#fbbf24");
    }

    function animateProjectileOnPath(points, color, timeOffset = 0) {
        if (points.length < 2) return;
        let totalLen = 0; let segs = [];
        for(let i=0; i<points.length-1; i++) {
            const len = Math.sqrt((points[i+1].x-points[i].x)**2 + (points[i+1].y-points[i].y)**2);
            segs.push(len); totalLen += len;
        }
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.stroke(); ctx.globalAlpha = 1.0;
        let dist = ((Date.now() / 1000 + timeOffset) * 180) % totalLen;
        let covered = 0;
        for(let i=0; i<segs.length; i++) {
            if (dist <= covered + segs[i]) {
                const ratio = (dist - covered) / segs[i];
                const px = points[i].x + (points[i+1].x - points[i].x) * ratio;
                const py = points[i].y + (points[i+1].y - points[i].y) * ratio;
                drawArrowHead(px, py, Math.atan2(points[i+1].y - points[i].y, points[i+1].x - points[i].x), color);
                break;
            }
            covered += segs[i];
        }
    }

    function drawAnimatedRays(d_o, d_i, h_o, h_i) {
        const eyeRatio = 45/60;
        const objTipX = centerX - d_o;
        const objTipY = centerY - (h_o * eyeRatio); 
        const imgTipX = centerX + d_i;
        const imgTipY = centerY - (h_i * eyeRatio);
        
        if (checkParallel.checked) {
            let pts = [{x: objTipX, y: objTipY}, {x: centerX, y: objTipY}];
            if (lensMode === 'convergent') {
                if (d_o > f) {
                    if (checkShowImage.checked) pts.push({x: imgTipX, y: imgTipY});
                    else pts.push({x: width, y: objTipY + ((centerY - objTipY)/f) * (width - centerX)});
                } else if (d_o < f) {
                    pts.push({x: width, y: objTipY + ((centerY - objTipY)/f) * (width - centerX)});
                } else { pts.push({x: width, y: objTipY}); }
            } else {
                let angle = Math.atan2(objTipY - centerY, centerX - (centerX + f));
                pts.push({x: width, y: objTipY + Math.tan(angle) * (width - centerX)});
            }
            animateProjectileOnPath(pts, "#22c55e", 0);
            
            if (lensMode === 'divergent') {
                ctx.setLineDash([5, 5]); ctx.strokeStyle = "#22c55e"; ctx.lineWidth = 1;
                ctx.beginPath(); 
                ctx.moveTo(centerX + f, centerY); 
                ctx.lineTo(centerX, objTipY);    
                ctx.stroke(); 
                ctx.setLineDash([]);
            } else if (d_i < 0) { 
                ctx.setLineDash([5, 5]); ctx.strokeStyle = "#22c55e"; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(centerX, objTipY); ctx.lineTo(imgTipX, imgTipY); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        if (checkCenter.checked) {
            let pts = [{x: objTipX, y: objTipY}];
            let angle = Math.atan2(centerY - objTipY, centerX - objTipX);
            if (d_i > 0 && checkShowImage.checked) {
                pts.push({x: imgTipX, y: imgTipY});
            } else {
                pts.push({x: width, y: centerY + Math.tan(angle) * (width - centerX)});
            }
            animateProjectileOnPath(pts, "#f97316", 0.3);
            if (lensMode === 'convergent' && d_i < 0) {
                ctx.setLineDash([5, 5]); ctx.strokeStyle = "#f97316"; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(objTipX, objTipY); ctx.lineTo(imgTipX, imgTipY); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        if (checkFocal.checked) {
            let pts = [{x: objTipX, y: objTipY}];
            if (lensMode === 'convergent') {
                if (d_o > f) {
                    let slope = (centerY - objTipY) / (centerX - f - objTipX);
                    let yAtLens = objTipY + slope * (centerX - objTipX);
                    pts.push({x: centerX, y: yAtLens});
                    if (checkShowImage.checked) pts.push({x: imgTipX, y: yAtLens});
                    else pts.push({x: width, y: yAtLens});
                } else if (d_o < f) {
                    let slope = (objTipY - centerY) / (objTipX - (centerX - f));
                    let yAtLens = centerY + slope * (centerX - (centerX - f));
                    pts.push({x: centerX, y: yAtLens}); pts.push({x: width, y: yAtLens});
                }
            } else {
                let slope = (centerY - objTipY) / (centerX - f - objTipX);
                let yAtLens = objTipY + slope * (centerX - objTipX);
                pts.push({x: centerX, y: yAtLens}, {x: width, y: yAtLens});
            }
            animateProjectileOnPath(pts, "#9333ea", 0.6);
            if (d_i < 0) {
                let yAtLens;
                if(lensMode === 'convergent') {
                    let slope = (objTipY - centerY) / (objTipX - (centerX - f));
                    yAtLens = centerY + slope * (centerX - (centerX - f));
                    ctx.setLineDash([3, 3]); ctx.strokeStyle = "#9333ea"; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(centerX - f, centerY); ctx.lineTo(objTipX, objTipY); ctx.stroke();
                } else {
                    let slope = (centerY - objTipY) / (centerX - f - objTipX);
                    yAtLens = objTipY + slope * (centerX - objTipX);
                    ctx.setLineDash([3, 3]); ctx.strokeStyle = "#9333ea"; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(centerX, yAtLens); ctx.lineTo(centerX - f, centerY); ctx.stroke();
                }
                ctx.beginPath(); ctx.moveTo(centerX, yAtLens); ctx.lineTo(imgTipX, yAtLens); ctx.stroke(); ctx.setLineDash([]);
            }
        }
    }

    function drawOpticalBench() {
        ctx.beginPath(); ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 2;
        ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); ctx.stroke();
        
        ctx.save();
        ctx.fillStyle = "#94a3b8";
        ctx.font = "italic 16px 'Times New Roman'";
        ctx.textAlign = "left";
        ctx.fillText("o", 20, centerY - 10);
        ctx.restore();

        drawPoint(centerX - Math.abs(f), centerY, "F");
        drawPoint(centerX + Math.abs(f), centerY, "F'");
        
        drawPoint(centerX, centerY, "O");

        if (lensMode === 'convergent') {
            drawPoint(centerX - 2*f, centerY, "2F", true);
            drawPoint(centerX + 2*f, centerY, "2F'", true);
        }
    }

    function drawPoint(x, y, label, isSmall = false) {
        ctx.beginPath(); ctx.fillStyle = "#64748b"; ctx.arc(x, y, isSmall ? 2.5 : 4, 0, Math.PI * 2); ctx.fill();
        ctx.font = isSmall ? "italic 11px 'Times New Roman'" : "italic bold 14px 'Times New Roman'"; 
        
        if (label === "O") {
            ctx.textAlign = "left";
            // √Åthelyezve jobbra lent: +10px X, +15px Y
            ctx.fillText(label, x + 10, y + 15);
        } else {
            ctx.textAlign = "center";
            ctx.fillText(label, x, y + 22);
        }
    }

    function drawLens() {
        ctx.beginPath(); ctx.strokeStyle = "#2563eb"; ctx.lineWidth = 3;
        
        if (lensMode === 'convergent') {
            ctx.moveTo(centerX, centerY - 120); ctx.lineTo(centerX, centerY + 120);
            ctx.moveTo(centerX - 15, centerY - 105); ctx.lineTo(centerX, centerY - 120); ctx.lineTo(centerX + 15, centerY - 105);
            ctx.moveTo(centerX - 15, centerY + 105); ctx.lineTo(centerX, centerY + 120); ctx.lineTo(centerX + 15, centerY + 105);
        } else {
            ctx.moveTo(centerX, centerY - 105); ctx.lineTo(centerX, centerY + 105);
            ctx.moveTo(centerX - 15, centerY - 120); ctx.lineTo(centerX, centerY - 105); ctx.lineTo(centerX + 15, centerY - 120);
            ctx.moveTo(centerX - 15, centerY + 120); ctx.lineTo(centerX, centerY + 105); ctx.lineTo(centerX + 15, centerY + 120);
        }
        ctx.stroke();
    }

    function drawSnail(x, y, h, alpha, isObject) {
        ctx.save(); ctx.translate(x, y);
        const s = Math.abs(h) / 60; 
        if (h > 0) ctx.scale(-s, s); else ctx.scale(s, -s);
        ctx.globalAlpha = alpha;
        ctx.font = "60px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "bottom";
        if (!isObject) ctx.filter = "hue-rotate(220deg) saturate(0.8)"; 
        ctx.fillText("üêå", 22, 10); 
        if (isObject) {
            ctx.fillStyle = "#ef4444"; ctx.beginPath(); ctx.arc(0, -45, 3, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }

    function drawArrowHead(x, y, angle, color) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
        ctx.beginPath(); ctx.moveTo(-8, -5); ctx.lineTo(3, 0); ctx.lineTo(-8, 5); ctx.fillStyle = color; ctx.fill();
        ctx.restore();
    }

    init();
</script>
</body>
<button onclick="location.href='index.html'" style="
    position: fixed; 
    top: 10px; 
    right: 140px; 
    padding: 10px 10px; 
    background: #FFF3eb; 
    color: green; 
    border: none; 
    border-radius: 8px; 
    cursor: pointer; 
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(2,2,2,0.2);
">üè†</button>
</html>